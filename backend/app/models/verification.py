# app/models/verification.py

from typing import Optional
from sqlmodel import Field, SQLModel, Relationship
from datetime import datetime, timedelta
from sqlalchemy import TEXT, DateTime
import uuid

# --- Verification Type Enum ---
class VerificationType(str, Enum):
    EMAIL = "email"
    PHONE = "phone"
    PASSWORD_RESET = "password_reset"


class VerificationBase(SQLModel):
    # Linkage (can be user_id OR email/phone for unauthenticated actions like password reset)
    user_id: Optional[uuid.UUID] = Field(default=None, foreign_key="user.id", index=True)
    target: str = Field(index=True, description="Email address or phone number being verified")
    
    # Content
    code: str = Field(index=True, description="The OTP or verification token")
    type: VerificationType
    
    # Status
    expires_at: datetime = Field(
        default_factory=lambda: datetime.utcnow() + timedelta(minutes=30), # Default 30 min expiration
        nullable=False,
        sa_column=Column("expires_at", DateTime)
    )
    is_used: bool = Field(default=False)
    
    # Metadata
    created_at: datetime = Field(default_factory=datetime.utcnow, nullable=False)


class Verification(VerificationBase, table=True):
    id: Optional[uuid.UUID] = Field(
        default_factory=uuid.uuid4, primary_key=True, index=True, nullable=False
    )
    
    # No direct relationship needed if linked by user_id or target string

# --- PYDANTIC SCHEMAS ---
class VerificationRead(VerificationBase):
    id: uuid.UUID
    
class VerificationCreate(SQLModel):
    # Minimal input for creation requests
    target: str
    type: VerificationType
    # code is generated by the service